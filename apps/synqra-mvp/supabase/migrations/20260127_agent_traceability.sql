-- Agent Decision Traceability System
-- Immutable audit logs for human review only
--
-- RULES:
-- - Logs are for human audit only
-- - No algorithmic feedback or self-optimization
-- - No user-facing exposure beyond "Assessment generated by X agents"

-- Agent roles enum
create type if not exists agent_role as enum (
  'analyzer',
  'validator',
  'council_voter',
  'synthesizer',
  'risk_assessor',
  'signal_generator'
);

-- Agent identity type
create type if not exists agent_identity as (
  name text,
  version text,
  role agent_role
);

-- Prompt snapshot type
create type if not exists prompt_snapshot as (
  version_hash text,
  template_name text,
  parameters jsonb
);

-- Agent version registry
-- Tracks all deployed agent versions
create table if not exists public.agent_version_registry (
  id uuid primary key default gen_random_uuid(),
  agent_name text not null,
  version text not null,
  role agent_role not null,
  capabilities text[] not null default '{}',
  model_used text not null,
  deployed_at timestamptz not null default now(),
  deprecated boolean default false,
  deprecation_reason text,
  created_at timestamptz default now(),
  
  unique(agent_name, version)
);

-- Prompt version registry
-- Tracks all prompt template versions
create table if not exists public.prompt_version_registry (
  id uuid primary key default gen_random_uuid(),
  version_hash text not null unique,
  template_name text not null,
  template_content text not null,
  parameters_schema jsonb not null default '{}',
  created_at timestamptz default now(),
  deprecated boolean default false,
  deprecation_reason text
);

-- Reasoning snapshots
-- Stores full agent reasoning chains (separate for size management)
create table if not exists public.reasoning_snapshots (
  id uuid primary key default gen_random_uuid(),
  assessment_id text not null,
  
  -- Reasoning data
  reasoning_chain jsonb not null,        -- Array of ReasoningStep
  context_used jsonb not null,           -- ContextSnapshot
  
  -- Metadata
  total_tokens integer not null,
  model_used text not null,
  temperature numeric not null,
  
  -- Storage metadata
  size_bytes integer not null,
  storage_path text,                     -- Optional external storage path
  
  created_at timestamptz not null default now(),
  
  -- Prevent updates after creation
  updated_at timestamptz default now()
);

-- Agent traceability records
-- Main audit log table (IMMUTABLE)
create table if not exists public.agent_traceability (
  id uuid primary key default gen_random_uuid(),
  assessment_id text not null,
  assessment_schema_version text not null,
  
  -- Agent metadata (stored as JSONB for flexibility)
  agents jsonb not null,                 -- Array of AgentIdentity
  primary_agent jsonb not null,          -- Single AgentIdentity
  
  -- Prompt metadata
  prompt jsonb not null,                 -- PromptSnapshot
  
  -- Reasoning reference
  reasoning_snapshot_id uuid not null references public.reasoning_snapshots(id),
  
  created_at timestamptz not null default now(),
  
  -- Prevent updates after creation
  updated_at timestamptz default now()
);

-- Indexes for audit queries
create index if not exists agent_traceability_assessment_idx on public.agent_traceability(assessment_id);
create index if not exists agent_traceability_created_idx on public.agent_traceability(created_at desc);
create index if not exists agent_traceability_schema_version_idx on public.agent_traceability(assessment_schema_version);
create index if not exists agent_traceability_primary_agent_idx on public.agent_traceability using gin(primary_agent);
create index if not exists agent_traceability_agents_idx on public.agent_traceability using gin(agents);

create index if not exists reasoning_snapshots_assessment_idx on public.reasoning_snapshots(assessment_id);
create index if not exists reasoning_snapshots_created_idx on public.reasoning_snapshots(created_at desc);

create index if not exists agent_version_registry_name_version_idx on public.agent_version_registry(agent_name, version);
create index if not exists prompt_version_registry_hash_idx on public.prompt_version_registry(version_hash);

-- Trigger to prevent updates to immutable tables
create or replace function prevent_traceability_updates()
returns trigger as $$
begin
  if TG_OP = 'UPDATE' then
    raise exception 'Agent traceability records are immutable and cannot be updated';
  end if;
  if TG_OP = 'DELETE' then
    raise exception 'Agent traceability records are immutable and cannot be deleted';
  end if;
  return NEW;
end;
$$ language plpgsql;

-- Apply immutability triggers
drop trigger if exists prevent_agent_traceability_updates on public.agent_traceability;
create trigger prevent_agent_traceability_updates
  before update or delete on public.agent_traceability
  for each row execute function prevent_traceability_updates();

drop trigger if exists prevent_reasoning_snapshot_updates on public.reasoning_snapshots;
create trigger prevent_reasoning_snapshot_updates
  before update or delete on public.reasoning_snapshots
  for each row execute function prevent_traceability_updates();

-- Function to create traceability record
create or replace function create_agent_traceability_record(
  p_assessment_id text,
  p_assessment_schema_version text,
  p_agents jsonb,
  p_primary_agent jsonb,
  p_prompt jsonb,
  p_reasoning_chain jsonb,
  p_context_used jsonb,
  p_total_tokens integer,
  p_model_used text,
  p_temperature numeric
)
returns uuid as $$
declare
  v_reasoning_id uuid;
  v_traceability_id uuid;
  v_size_bytes integer;
begin
  -- Calculate size of reasoning data
  v_size_bytes := octet_length(p_reasoning_chain::text) + octet_length(p_context_used::text);
  
  -- Create reasoning snapshot
  insert into public.reasoning_snapshots (
    assessment_id,
    reasoning_chain,
    context_used,
    total_tokens,
    model_used,
    temperature,
    size_bytes
  ) values (
    p_assessment_id,
    p_reasoning_chain,
    p_context_used,
    p_total_tokens,
    p_model_used,
    p_temperature,
    v_size_bytes
  ) returning id into v_reasoning_id;
  
  -- Create traceability record
  insert into public.agent_traceability (
    assessment_id,
    assessment_schema_version,
    agents,
    primary_agent,
    prompt,
    reasoning_snapshot_id
  ) values (
    p_assessment_id,
    p_assessment_schema_version,
    p_agents,
    p_primary_agent,
    p_prompt,
    v_reasoning_id
  ) returning id into v_traceability_id;
  
  return v_traceability_id;
end;
$$ language plpgsql security definer;

-- Function to get agent attribution (minimal user-facing data)
create or replace function get_agent_attribution(p_assessment_id text)
returns table(
  agent_count integer,
  primary_agent_name text,
  version text,
  generated_at timestamptz
) as $$
begin
  return query
  select
    jsonb_array_length(t.agents) as agent_count,
    t.primary_agent->>'name' as primary_agent_name,
    t.primary_agent->>'version' as version,
    t.created_at as generated_at
  from public.agent_traceability t
  where t.assessment_id = p_assessment_id
  limit 1;
end;
$$ language plpgsql security definer;

-- Function to query audit logs (admin only)
create or replace function query_agent_audit_logs(
  p_assessment_id text default null,
  p_agent_name text default null,
  p_date_from timestamptz default null,
  p_date_to timestamptz default null,
  p_limit integer default 100
)
returns table(
  id uuid,
  assessment_id text,
  assessment_schema_version text,
  agents jsonb,
  primary_agent jsonb,
  prompt jsonb,
  reasoning_snapshot_id uuid,
  created_at timestamptz
) as $$
begin
  return query
  select
    t.id,
    t.assessment_id,
    t.assessment_schema_version,
    t.agents,
    t.primary_agent,
    t.prompt,
    t.reasoning_snapshot_id,
    t.created_at
  from public.agent_traceability t
  where
    (p_assessment_id is null or t.assessment_id = p_assessment_id)
    and (p_agent_name is null or t.primary_agent->>'name' = p_agent_name)
    and (p_date_from is null or t.created_at >= p_date_from)
    and (p_date_to is null or t.created_at <= p_date_to)
  order by t.created_at desc
  limit p_limit;
end;
$$ language plpgsql security definer;

-- Function to get reasoning snapshot
create or replace function get_reasoning_snapshot(p_snapshot_id uuid)
returns table(
  id uuid,
  assessment_id text,
  reasoning_chain jsonb,
  context_used jsonb,
  total_tokens integer,
  model_used text,
  temperature numeric,
  size_bytes integer,
  created_at timestamptz
) as $$
begin
  return query
  select
    r.id,
    r.assessment_id,
    r.reasoning_chain,
    r.context_used,
    r.total_tokens,
    r.model_used,
    r.temperature,
    r.size_bytes,
    r.created_at
  from public.reasoning_snapshots r
  where r.id = p_snapshot_id;
end;
$$ language plpgsql security definer;

-- Function to register agent version
create or replace function register_agent_version(
  p_agent_name text,
  p_version text,
  p_role agent_role,
  p_capabilities text[],
  p_model_used text
)
returns uuid as $$
declare
  v_id uuid;
begin
  insert into public.agent_version_registry (
    agent_name,
    version,
    role,
    capabilities,
    model_used
  ) values (
    p_agent_name,
    p_version,
    p_role,
    p_capabilities,
    p_model_used
  )
  on conflict (agent_name, version) do update
  set capabilities = excluded.capabilities,
      model_used = excluded.model_used
  returning id into v_id;
  
  return v_id;
end;
$$ language plpgsql security definer;

-- Function to register prompt version
create or replace function register_prompt_version(
  p_version_hash text,
  p_template_name text,
  p_template_content text,
  p_parameters_schema jsonb
)
returns uuid as $$
declare
  v_id uuid;
begin
  insert into public.prompt_version_registry (
    version_hash,
    template_name,
    template_content,
    parameters_schema
  ) values (
    p_version_hash,
    p_template_name,
    p_template_content,
    p_parameters_schema
  )
  on conflict (version_hash) do nothing
  returning id into v_id;
  
  return v_id;
end;
$$ language plpgsql security definer;

-- Insert initial agent versions (examples)
insert into public.agent_version_registry (agent_name, version, role, capabilities, model_used)
values
  ('aura-fx-analyzer', '1.0.0', 'analyzer', ARRAY['technical_analysis', 'pattern_recognition'], 'gpt-4'),
  ('council-voter-1', '1.0.0', 'council_voter', ARRAY['consensus_voting', 'risk_assessment'], 'gpt-4'),
  ('signal-generator', '1.0.0', 'signal_generator', ARRAY['signal_creation', 'probability_calculation'], 'gpt-4')
on conflict (agent_name, version) do nothing;

-- Comments for documentation
comment on table public.agent_traceability is 'IMMUTABLE audit log of agent decisions - human review only';
comment on table public.reasoning_snapshots is 'IMMUTABLE reasoning chains - human review only';
comment on table public.agent_version_registry is 'Registry of all deployed agent versions';
comment on table public.prompt_version_registry is 'Registry of all prompt template versions';

comment on function create_agent_traceability_record is 'Creates immutable traceability record for assessment';
comment on function get_agent_attribution is 'Returns minimal user-facing agent attribution';
comment on function query_agent_audit_logs is 'Admin-only audit log query interface';
comment on function get_reasoning_snapshot is 'Retrieves full reasoning snapshot for audit';
comment on function register_agent_version is 'Registers new agent version in registry';
comment on function register_prompt_version is 'Registers new prompt version in registry';

-- CRITICAL: Add constraint to prevent algorithmic use
comment on column public.agent_traceability.id is 'AUDIT ONLY - Do not use in decision logic';
comment on column public.reasoning_snapshots.id is 'AUDIT ONLY - Do not use in decision logic';
