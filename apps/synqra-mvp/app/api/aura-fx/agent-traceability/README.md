# Agent Decision Traceability System

## Overview

Immutable audit logging system for agent decisions. Tags every assessment with agent metadata, prompt versions, and reasoning snapshots for human review and quality assurance.

---

## Core Principles

### ✅ Human Audit Only
- Logs are for human review, debugging, and quality assurance
- **NOT** for algorithmic feedback or self-optimization
- **NOT** for training or fine-tuning models

### ✅ Minimal User Exposure
- Users see only: "Assessment generated by X agents"
- No detailed reasoning or decision logic exposed
- Simple, non-technical language

### ✅ Immutable Records
- Cannot be updated after creation
- Cannot be deleted
- Versioned alongside assessment schema
- Database triggers enforce immutability

---

## What Gets Logged

Every assessment is tagged with:

### 1. Agent Metadata
- **Agent name**: e.g., "aura-fx-analyzer"
- **Agent version**: Semantic version (1.0.0)
- **Agent role**: analyzer, validator, council_voter, etc.
- **All agents involved**: Complete list of participating agents

### 2. Prompt Version
- **Version hash**: SHA-256 hash of prompt template
- **Template name**: e.g., "aura-fx-confluence-analysis"
- **Parameters**: Prompt parameters used

### 3. Reasoning Snapshot (Read-Only)
- **Reasoning chain**: Step-by-step agent actions
- **Context used**: Market data, indicators, external sources
- **Model metadata**: Model used, tokens, temperature
- **Stored separately**: For size management

### 4. Assessment Context
- **Schema version**: Assessment schema version
- **Timestamp**: When assessment was generated
- **Assessment ID**: Reference to assessment record

---

## Database Schema

### Tables

**`agent_version_registry`** - Agent version tracking
```sql
- agent_name: text
- version: text
- role: agent_role enum
- capabilities: text[]
- model_used: text
- deployed_at: timestamptz
- deprecated: boolean
```

**`prompt_version_registry`** - Prompt version tracking
```sql
- version_hash: text (unique)
- template_name: text
- template_content: text
- parameters_schema: jsonb
- created_at: timestamptz
- deprecated: boolean
```

**`reasoning_snapshots`** - Full reasoning chains
```sql
- id: uuid
- assessment_id: text
- reasoning_chain: jsonb
- context_used: jsonb
- total_tokens: integer
- model_used: text
- temperature: numeric
- size_bytes: integer
- created_at: timestamptz
```

**`agent_traceability`** - Main audit log (IMMUTABLE)
```sql
- id: uuid
- assessment_id: text
- assessment_schema_version: text
- agents: jsonb (array)
- primary_agent: jsonb
- prompt: jsonb
- reasoning_snapshot_id: uuid (FK)
- created_at: timestamptz
```

### Immutability Enforcement

```sql
-- Triggers prevent updates and deletes
CREATE TRIGGER prevent_agent_traceability_updates
  BEFORE UPDATE OR DELETE ON agent_traceability
  FOR EACH ROW EXECUTE FUNCTION prevent_traceability_updates();
```

---

## Usage

### 1. Register Agent Version

```typescript
import { TraceabilityService } from "@/app/api/aura-fx/agent-traceability";

const service = new TraceabilityService();

await service.registerAgentVersion(
  "aura-fx-analyzer",
  "1.0.0",
  "analyzer",
  ["technical_analysis", "pattern_recognition"],
  "gpt-4"
);
```

### 2. Register Prompt Version

```typescript
const templateContent = `
Analyze the following market data and provide directional assessment...
`;

await service.registerPromptVersion(
  "aura-fx-confluence-analysis",
  templateContent,
  {
    symbol: { type: "string" },
    timeframe: { type: "string" },
    indicators: { type: "array" },
  }
);
```

### 3. Generate Assessment with Traceability

```typescript
import { AssessmentWithTraceability, createAgentIdentity } from "@/app/api/aura-fx/agent-traceability";

const wrapper = new AssessmentWithTraceability("1.0.0");

const result = await wrapper.execute(
  async () => generateAssessment(), // Your assessment function
  {
    assessmentId: "signal-12345",
    symbol: "BTCUSDT",
    timeframe: "H4",
    dataPoints: 100,
    timestampRange: { start: "...", end: "..." },
    indicatorsUsed: ["EMA", "RSI", "MACD"],
    externalDataSources: ["Binance API"],
  },
  {
    agents: [
      createAgentIdentity("aura-fx-analyzer", "1.0.0", "analyzer"),
      createAgentIdentity("signal-generator", "1.0.0", "signal_generator"),
    ],
    primaryAgent: createAgentIdentity("aura-fx-analyzer", "1.0.0", "analyzer"),
    reasoningSteps: [...],
    totalTokens: 0,
    modelUsed: "rule-based-v1",
    temperature: 0,
  },
  {
    templateName: "aura-fx-confluence-analysis",
    templateContent: "...",
    parameters: { symbol: "BTCUSDT", timeframe: "H4" },
  }
);
```

### 4. Get User-Facing Attribution

```typescript
const attribution = await service.getAgentAttribution("signal-12345");

// Returns:
// {
//   agent_count: 2,
//   primary_agent_name: "aura-fx-analyzer",
//   version: "1.0.0",
//   generated_at: "2026-01-27T14:30:00.000Z"
// }
```

### 5. Query Audit Logs (Admin Only)

```typescript
const logs = await service.queryAuditLogs({
  assessment_id: "signal-12345",
  agent_name: "aura-fx-analyzer",
  date_from: "2026-01-01T00:00:00.000Z",
  date_to: "2026-01-31T23:59:59.000Z",
  limit: 100,
});
```

### 6. Get Reasoning Snapshot (Admin Only)

```typescript
const snapshot = await service.getReasoningSnapshot(
  "660e8400-e29b-41d4-a716-446655440001"
);

// Returns full reasoning chain with context
```

---

## API Endpoints

### Admin Audit API

**GET** `/api/aura-fx/agent-traceability/audit`

Query audit logs (admin only)

Query params:
- `assessment_id`: Filter by assessment ID
- `agent_name`: Filter by agent name
- `date_from`: Start date (ISO 8601)
- `date_to`: End date (ISO 8601)
- `limit`: Max records (default 100)

Response:
```json
{
  "success": true,
  "data": {
    "records": [...],
    "total_count": 42,
    "page": 1,
    "page_size": 100
  },
  "meta": {
    "audit_only": true,
    "warning": "This data is for human review only"
  }
}
```

**POST** `/api/aura-fx/agent-traceability/audit`

Get reasoning snapshot (admin only)

Body:
```json
{
  "snapshot_id": "660e8400-e29b-41d4-a716-446655440001"
}
```

---

## User-Facing Components

### Agent Attribution (Inline)

```tsx
import { AgentAttribution } from "@/components/aura-fx/AgentAttribution";

<AgentAttribution
  agentCount={2}
  primaryAgentName="aura-fx-analyzer"
  version="1.0.0"
  generatedAt="2026-01-27T14:30:00.000Z"
  variant="inline"
/>
```

Displays:
```
ℹ️ Assessment generated by 2 agents
```

Click to expand:
```
Primary Agent: AuraFX Analysis
Version: 1.0.0
Generated: Jan 27, 2:30 PM

Agent decisions are logged for quality
assurance and audit purposes.
```

### Agent Attribution (Footer)

```tsx
<AgentAttribution
  agentCount={2}
  primaryAgentName="aura-fx-analyzer"
  version="1.0.0"
  generatedAt="2026-01-27T14:30:00.000Z"
  variant="footer"
/>
```

Displays:
```
─────────────────────────────────────
Assessment generated by 2 agents  Jan 27, 2:30 PM
```

### Compact Attribution (List Views)

```tsx
import { CompactAgentAttribution } from "@/components/aura-fx/AgentAttribution";

<CompactAgentAttribution
  agentCount={2}
  generatedAt="2026-01-27T14:30:00.000Z"
/>
```

Displays:
```
ℹ️ 2 agents • 2:30 PM
```

---

## Example Logged Record

See `EXAMPLE_RECORD.json` for complete example.

**Summary**:
- Assessment ID: `aura-fx-signal-2026-01-27-12345`
- Agents: `aura-fx-analyzer` (v1.0.0), `signal-generator` (v1.0.0)
- Prompt: `aura-fx-confluence-analysis` (hash: `a3f5c8d2e1b4f6a9`)
- Reasoning: 3 steps (analyze → calculate → generate)
- Context: 100 H4 candles, 5 indicators, 1 external source
- User sees: "Assessment generated by 2 agents"

---

## Critical Rules

### ❌ DO NOT Use Logs in Decision Logic

```typescript
// ❌ WRONG - Using audit logs for decisions
const pastAssessments = await queryAuditLogs({ agent_name: "..." });
const avgConfluence = calculateAverage(pastAssessments);
if (avgConfluence > 0.8) {
  // Make decision based on past logs
}

// ✅ CORRECT - Logs are for audit only
const attribution = await getAgentAttribution(assessmentId);
// Only show to user, never use in logic
```

### ❌ DO NOT Expose Detailed Reasoning to Users

```typescript
// ❌ WRONG - Exposing reasoning to users
<div>
  <h3>Agent Reasoning:</h3>
  <pre>{JSON.stringify(reasoningSnapshot, null, 2)}</pre>
</div>

// ✅ CORRECT - Minimal attribution only
<AgentAttribution
  agentCount={2}
  primaryAgentName="aura-fx-analyzer"
  version="1.0.0"
  generatedAt="2026-01-27T14:30:00.000Z"
/>
```

### ❌ DO NOT Modify or Delete Records

```typescript
// ❌ WRONG - Attempting to modify
await supabase
  .from("agent_traceability")
  .update({ agents: newAgents })
  .eq("id", recordId);
// This will throw: "Agent traceability records are immutable"

// ✅ CORRECT - Records are immutable
// Create new record if needed, never modify existing
```

### ✅ DO Use for Human Audit

```typescript
// ✅ CORRECT - Admin reviewing decisions
const logs = await service.queryAuditLogs({
  date_from: "2026-01-01",
  date_to: "2026-01-31",
});

// Manual review for:
// - Quality assurance
// - Debugging issues
// - Understanding agent behavior
// - Compliance and audit
```

---

## Monitoring & Maintenance

### Query Audit Logs

```sql
-- Recent assessments by agent
SELECT
  assessment_id,
  primary_agent->>'name' as agent_name,
  primary_agent->>'version' as version,
  created_at
FROM agent_traceability
ORDER BY created_at DESC
LIMIT 100;

-- Agent usage statistics
SELECT
  primary_agent->>'name' as agent_name,
  COUNT(*) as assessment_count
FROM agent_traceability
WHERE created_at > NOW() - INTERVAL '7 days'
GROUP BY primary_agent->>'name'
ORDER BY assessment_count DESC;
```

### Storage Management

```sql
-- Check reasoning snapshot sizes
SELECT
  assessment_id,
  size_bytes,
  pg_size_pretty(size_bytes::bigint) as size_human
FROM reasoning_snapshots
ORDER BY size_bytes DESC
LIMIT 20;

-- Total storage used
SELECT
  COUNT(*) as total_records,
  SUM(size_bytes) as total_bytes,
  pg_size_pretty(SUM(size_bytes)::bigint) as total_size
FROM reasoning_snapshots;
```

### Cleanup (If Needed)

```sql
-- Archive old records (move to cold storage)
-- DO NOT DELETE - records are immutable
-- Instead, move to separate archive table or external storage

-- Example: Move to archive table
INSERT INTO agent_traceability_archive
SELECT * FROM agent_traceability
WHERE created_at < NOW() - INTERVAL '1 year';
```

---

## Integration Checklist

- [ ] Register all agent versions in registry
- [ ] Register all prompt versions in registry
- [ ] Wrap assessment generation with `AssessmentWithTraceability`
- [ ] Add `<AgentAttribution />` to assessment UI
- [ ] Set up admin audit dashboard
- [ ] Configure admin authentication for audit API
- [ ] Set up monitoring for storage usage
- [ ] Document agent roles and capabilities
- [ ] Train team on audit log usage
- [ ] Establish audit review process

---

## Troubleshooting

### Issue: Traceability logging fails

**Check**: Error logs for service failures
```typescript
// Traceability logging should not block assessment
try {
  await logTraceability(...);
} catch (error) {
  console.error("Failed to log traceability:", error);
  // Continue with assessment
}
```

### Issue: Storage growing too large

**Solution**: Implement external storage for large reasoning snapshots
```typescript
// Store large snapshots in S3/external storage
if (reasoningChain.length > 1000) {
  const storageUrl = await uploadToExternalStorage(reasoningChain);
  // Store only reference in database
}
```

### Issue: Cannot update record

**Expected**: Records are immutable by design
```sql
-- This is correct behavior
ERROR: Agent traceability records are immutable and cannot be updated
```

---

**Implementation Complete** ✅

All agent decisions are now traceable with immutable audit logs for human review.
