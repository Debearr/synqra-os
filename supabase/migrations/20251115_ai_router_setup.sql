-- ============================================================
-- AI ROUTER - SUPABASE SETUP
-- ============================================================
-- Creates tables and indexes for AI model usage tracking
-- Run this migration to enable cost logging

-- Create ai_model_usage table
CREATE TABLE IF NOT EXISTS ai_model_usage (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  task_id TEXT NOT NULL,
  model TEXT NOT NULL,
  input_tokens INTEGER NOT NULL DEFAULT 0,
  output_tokens INTEGER NOT NULL DEFAULT 0,
  estimated_cost DECIMAL(10, 6) NOT NULL DEFAULT 0,
  actual_cost DECIMAL(10, 6) NOT NULL DEFAULT 0,
  complexity DECIMAL(3, 2) NOT NULL DEFAULT 0,
  cache_hit BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for efficient queries
CREATE INDEX IF NOT EXISTS idx_ai_model_usage_created_at 
  ON ai_model_usage(created_at DESC);

CREATE INDEX IF NOT EXISTS idx_ai_model_usage_model 
  ON ai_model_usage(model);

CREATE INDEX IF NOT EXISTS idx_ai_model_usage_task_id 
  ON ai_model_usage(task_id);

CREATE INDEX IF NOT EXISTS idx_ai_model_usage_cache_hit 
  ON ai_model_usage(cache_hit);

-- Enable Row Level Security (RLS)
ALTER TABLE ai_model_usage ENABLE ROW LEVEL SECURITY;

-- Policy: Allow service role to insert
CREATE POLICY IF NOT EXISTS "Allow service role to insert ai_model_usage" 
  ON ai_model_usage
  FOR INSERT
  TO service_role
  WITH CHECK (true);

-- Policy: Allow service role to select
CREATE POLICY IF NOT EXISTS "Allow service role to select ai_model_usage" 
  ON ai_model_usage
  FOR SELECT
  TO service_role
  USING (true);

-- Policy: Allow authenticated users to view their own usage (optional)
-- Uncomment if you want users to see their usage stats
-- CREATE POLICY IF NOT EXISTS "Allow users to view their usage" 
--   ON ai_model_usage
--   FOR SELECT
--   TO authenticated
--   USING (auth.uid()::text = task_id);

-- Create materialized view for cost analytics (optional optimization)
CREATE MATERIALIZED VIEW IF NOT EXISTS ai_cost_summary AS
SELECT
  DATE(created_at) as date,
  model,
  COUNT(*) as task_count,
  SUM(input_tokens) as total_input_tokens,
  SUM(output_tokens) as total_output_tokens,
  SUM(actual_cost) as total_cost,
  AVG(complexity) as avg_complexity,
  SUM(CASE WHEN cache_hit THEN 1 ELSE 0 END)::FLOAT / COUNT(*) as cache_hit_rate
FROM ai_model_usage
GROUP BY DATE(created_at), model
ORDER BY date DESC, model;

-- Create index on materialized view
CREATE INDEX IF NOT EXISTS idx_ai_cost_summary_date 
  ON ai_cost_summary(date DESC);

-- Function to refresh materialized view (call daily via cron)
CREATE OR REPLACE FUNCTION refresh_ai_cost_summary()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY ai_cost_summary;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission to service role
GRANT EXECUTE ON FUNCTION refresh_ai_cost_summary() TO service_role;

-- Comments for documentation
COMMENT ON TABLE ai_model_usage IS 'Tracks all AI model usage for cost analysis and optimization';
COMMENT ON COLUMN ai_model_usage.task_id IS 'Unique identifier for the task (generated by router)';
COMMENT ON COLUMN ai_model_usage.model IS 'Model used: mistral, deepseek, claude, gpt-5, or cached';
COMMENT ON COLUMN ai_model_usage.input_tokens IS 'Number of input tokens consumed';
COMMENT ON COLUMN ai_model_usage.output_tokens IS 'Number of output tokens generated';
COMMENT ON COLUMN ai_model_usage.estimated_cost IS 'Estimated cost before execution (USD)';
COMMENT ON COLUMN ai_model_usage.actual_cost IS 'Actual cost after execution (USD)';
COMMENT ON COLUMN ai_model_usage.complexity IS 'Complexity score (0-1) used for routing decision';
COMMENT ON COLUMN ai_model_usage.cache_hit IS 'Whether response was served from cache';

-- Example queries for analytics

-- Daily cost breakdown
-- SELECT 
--   DATE(created_at) as date,
--   model,
--   COUNT(*) as tasks,
--   SUM(actual_cost) as cost
-- FROM ai_model_usage
-- WHERE created_at >= NOW() - INTERVAL '30 days'
-- GROUP BY DATE(created_at), model
-- ORDER BY date DESC, cost DESC;

-- Cache hit rate by day
-- SELECT 
--   DATE(created_at) as date,
--   COUNT(*) as total_tasks,
--   SUM(CASE WHEN cache_hit THEN 1 ELSE 0 END) as cache_hits,
--   (SUM(CASE WHEN cache_hit THEN 1 ELSE 0 END)::FLOAT / COUNT(*) * 100)::DECIMAL(5,2) as cache_hit_rate
-- FROM ai_model_usage
-- WHERE created_at >= NOW() - INTERVAL '30 days'
-- GROUP BY DATE(created_at)
-- ORDER BY date DESC;

-- Cost savings calculation
-- SELECT
--   SUM(CASE WHEN model = 'cached' THEN 0 ELSE actual_cost END) as total_cost,
--   COUNT(*) * 0.0105 as if_all_claude,
--   (COUNT(*) * 0.0105) - SUM(CASE WHEN model = 'cached' THEN 0 ELSE actual_cost END) as savings,
--   ((COUNT(*) * 0.0105) - SUM(CASE WHEN model = 'cached' THEN 0 ELSE actual_cost END)) / (COUNT(*) * 0.0105) * 100 as savings_percentage
-- FROM ai_model_usage
-- WHERE created_at >= NOW() - INTERVAL '30 days';
